package modules

import (
	"context"
	"fmt"
	"net"
	"strconv"
	"strings"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/widget"
)

type vulnerabilityModule struct {
	content     fyne.CanvasObject
	targetEntry *widget.Entry
	runButton   *widget.Button
	statusLabel *widget.Label
	resultsList *widget.List
	findings    []vulnerabilityFinding
	cancel      context.CancelFunc
	running     bool
}

type vulnerabilityFinding struct {
	Service     string
	Severity    string
	Description string
	Remediation string
}

func (m *vulnerabilityModule) Name() string {
	return "Vulnerability Scanner"
}

func (m *vulnerabilityModule) Content() fyne.CanvasObject {
	if m.content != nil {
		return m.content
	}

	m.targetEntry = widget.NewEntry()
	m.targetEntry.SetPlaceHolder("Target host (IP or hostname)")

	m.runButton = widget.NewButton("Run Vulnerability Scan", m.toggleRun)

	entryField := container.New(layout.NewGridWrapLayout(fyne.NewSize(260, m.targetEntry.MinSize().Height)), m.targetEntry)
	buttonWrap := container.New(layout.NewGridWrapLayout(fyne.NewSize(220, m.runButton.MinSize().Height)), m.runButton)
	buttonSpacer := container.New(layout.NewGridWrapLayout(fyne.NewSize(12, m.runButton.MinSize().Height)), widget.NewLabel(""))
	entryRow := container.NewHBox(entryField, buttonSpacer, buttonWrap, layout.NewSpacer())

	m.statusLabel = widget.NewLabel("Idle. Provide a target and click Run.")

	m.resultsList = widget.NewList(
		func() int { return len(m.findings) },
		func() fyne.CanvasObject { return widget.NewLabel("") },
		func(i int, obj fyne.CanvasObject) {
			f := m.findings[i]
			obj.(*widget.Label).SetText(fmt.Sprintf("[%s] %s - %s\nRemediation: %s", f.Severity, f.Service, f.Description, f.Remediation))
		},
	)

	scroll := container.NewVScroll(m.resultsList)
	scroll.SetMinSize(fyne.NewSize(0, 300))

	m.content = container.NewVBox(
		widget.NewLabelWithStyle("Vulnerability Scanner", fyne.TextAlignLeading, fyne.TextStyle{Bold: true}),
		widget.NewLabel("Run lightweight checks for common exposures."),
		entryRow,
		m.statusLabel,
		widget.NewCard("Findings", "Severity ratings and remediation suggestions.", container.NewMax(scroll)),
	)

	return m.content
}

func (m *vulnerabilityModule) toggleRun() {
	if m.running {
		if m.cancel != nil {
			m.cancel()
		}
		m.setStatus("Stopping vulnerability scan ...")
		return
	}

	target := strings.TrimSpace(m.targetEntry.Text)
	if target == "" {
		m.setStatus("Enter a hostname or IP address before scanning.")
		return
	}

	ctx, cancel := context.WithCancel(context.Background())
	m.cancel = cancel
	m.findings = nil
	m.resultsList.Refresh()
	m.setRunning(true)
	m.setStatus(fmt.Sprintf("Running vulnerability checks for %s ...", target))

	go m.performScan(ctx, target)
}

func (m *vulnerabilityModule) performScan(ctx context.Context, target string) {
	rules := vulnerabilityRules()
	results := make([]vulnerabilityFinding, 0, len(rules))

	for _, rule := range rules {
		select {
		case <-ctx.Done():
			m.queueStatus("Vulnerability scan stopped.")
			m.setRunning(false)
			return
		default:
		}

		address := net.JoinHostPort(target, strconv.Itoa(rule.Port))
		if portOpen(address, 500*time.Millisecond) {
			results = append(results, vulnerabilityFinding{
				Service:     rule.Service,
				Severity:    rule.Severity,
				Description: rule.Description,
				Remediation: rule.Remediation,
			})
		}
	}

	if len(results) == 0 {
		results = append(results, vulnerabilityFinding{
			Service:     "Informational",
			Severity:    "Low",
			Description: "No high-risk signatures detected with the lightweight checks executed.",
			Remediation: "Run a full vulnerability scan (e.g., Nmap or Nessus) for comprehensive coverage.",
		})
	}

	m.queueOnMain(func() {
		m.findings = results
		m.resultsList.Refresh()
		m.setStatus(fmt.Sprintf("Vulnerability scan complete for %s (%d finding(s)).", target, len(results)))
		m.setRunning(false)
	})
}

func (m *vulnerabilityModule) setStatus(text string) {
	if m.statusLabel != nil {
		m.statusLabel.SetText(text)
	}
}

func (m *vulnerabilityModule) setRunning(active bool) {
	m.running = active
	if m.runButton != nil {
		if active {
			m.runButton.SetText("Stop Vulnerability Scan")
		} else {
			m.runButton.SetText("Run Vulnerability Scan")
		}
		m.runButton.Refresh()
	}
	if !active {
		m.cancel = nil
	}
}

func (m *vulnerabilityModule) queueStatus(msg string) {
	m.queueOnMain(func() {
		m.setStatus(msg)
	})
}

func (m *vulnerabilityModule) queueOnMain(fn func()) {
	if app := fyne.CurrentApp(); app != nil {
		if drv := app.Driver(); drv != nil {
			if runner, ok := drv.(interface{ RunOnMain(func()) }); ok {
				runner.RunOnMain(fn)
				return
			}
		}
	}
	fn()
}

type vulnerabilityRule struct {
	Port        int
	Service     string
	Severity    string
	Description string
	Remediation string
}

func vulnerabilityRules() []vulnerabilityRule {
	return []vulnerabilityRule{
		{21, "FTP (21/tcp)", "Medium", "FTP service detected. Anonymous or unencrypted FTP can expose credentials.", "Disable FTP or enforce FTPS/SFTP with strong authentication."},
		{22, "SSH (22/tcp)", "Medium", "SSH reachable from the network. Weak passwords enable brute-force attacks.", "Restrict SSH to trusted IPs and require key-based authentication."},
		{80, "HTTP (80/tcp)", "High", "Plain HTTP service detected. Traffic is unencrypted and susceptible to MITM attacks.", "Redirect HTTP to HTTPS and enforce TLS 1.2+."},
		{443, "HTTPS (443/tcp)", "Medium", "HTTPS service reachable. Ensure TLS configuration is hardened.", "Disable legacy ciphers, enable HSTS, and use modern certificates."},
		{3389, "RDP (3389/tcp)", "High", "Remote Desktop exposed. RDP is a common entry vector for ransomware.", "Restrict RDP to VPN users, enable MFA, and keep patches current."},
		{6379, "Redis (6379/tcp)", "Critical", "Redis port open. Default Redis has no authentication and can be exploited remotely.", "Bind Redis to localhost, enable AUTH, or deploy behind a firewall."},
	}
}

func portOpen(address string, timeout time.Duration) bool {
	conn, err := net.DialTimeout("tcp", address, timeout)
	if err != nil {
		return false
	}
	conn.Close()
	return true
}
